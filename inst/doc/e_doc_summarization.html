<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Thomas W. Jones" />

<meta name="date" content="2018-04-29" />

<title></title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore"><ol start="5" style="list-style-type: decimal">
<li>Document summarization</li>
</ol></h1>
<h4 class="author"><em>Thomas W. Jones</em></h4>
<h4 class="date"><em>2018-04-29</em></h4>



<p>In this example we’ll use text embeddings and a bit of network analysis to build a basic document summarizer.</p>
<p>Many document summarizers, as the one we’ll build here, do not generate language. Instead, they break a document down into sentences and then use some mechanism to score each sentence for relevance. Sentences with the top scores are returned as the “summary.” For more information on summarization, a good place to start is <a href="https://en.wikipedia.org/wiki/Automatic_summarization">here</a>.</p>
<p>The summarizer we’ll build is a version of the <a href="https://en.wikipedia.org/wiki/Automatic_summarization#Unsupervised_approach:_TextRank">TextRank algorithm</a>. We will split a document into sentences, create a nearest-neighbor network where sentences are connected to other similar sentences, and rank the sentences according to <a href="https://en.wikipedia.org/wiki/Eigenvector_centrality">eigenvector centrality</a>.</p>
<p>We will use a word embedding model, created on a whole corpus, to project the sentences into the embedding space. Once in the embedding space, we will measure similarity between documents using <a href="https://en.wikipedia.org/wiki/Hellinger_distance">Hellinger distance</a>. Hellinger distance is a metric specifically for probability distributions. Since we’ll use LDA to create embeddings to a probability space, it’s a useful measure.</p>
<div id="getting-started" class="section level1">
<h1>Getting started</h1>
<p>We’ll use the movie review data set from <code>text2vec</code> again. The first thing we need to do is create a TCM and embedding model. We will skip evaluation such as R-squared, coherence, inspecting top terms, etc. However, in any real application, I’d strongly suggest evaluating your models at every step of the way.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(textmineR)

<span class="co"># load the data</span>
<span class="kw">data</span>(movie_review, <span class="dt">package =</span> <span class="st">&quot;text2vec&quot;</span>)

<span class="co"># let's take a sample so the demo will run quickly</span>
<span class="co"># note: textmineR is generally quite scaleable, depending on your system</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
s &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(movie_review), <span class="dv">500</span>)

movie_review &lt;-<span class="st"> </span>movie_review[ s , ]

<span class="co"># let's get those nasty &quot;&lt;br /&gt;&quot; symbols out of the way</span>
movie_review<span class="op">$</span>review &lt;-<span class="st"> </span>stringr<span class="op">::</span><span class="kw">str_replace_all</span>(movie_review<span class="op">$</span>review, <span class="st">&quot;&lt;br */&gt;&quot;</span>, <span class="st">&quot;&quot;</span>)

<span class="co"># First create a TCM using skip grams, we'll use a 5-word window</span>
<span class="co"># most options available on CreateDtm are also available for CreateTcm</span>
tcm &lt;-<span class="st"> </span><span class="kw">CreateTcm</span>(<span class="dt">doc_vec =</span> movie_review<span class="op">$</span>review,
                 <span class="dt">skipgram_window =</span> <span class="dv">5</span>,
                 <span class="dt">verbose =</span> <span class="ot">FALSE</span>,
                 <span class="dt">cpus =</span> <span class="dv">2</span>)

<span class="co"># use LDA to get embeddings into probability space</span>
<span class="co"># This will take considerably longer as the TCM matrix has many more rows </span>
<span class="co"># than a DTM</span>
embeddings &lt;-<span class="st"> </span><span class="kw">FitLdaModel</span>(<span class="dt">dtm =</span> tcm,
                          <span class="dt">k =</span> <span class="dv">100</span>,
                          <span class="dt">iterations =</span> <span class="dv">500</span>,
                          <span class="dt">cpus =</span> <span class="dv">2</span>)

<span class="co"># and we'll get our projection matrix</span>
embeddings<span class="op">$</span>phi_prime &lt;-<span class="st"> </span><span class="kw">CalcPhiPrime</span>(<span class="dt">phi =</span> embeddings<span class="op">$</span>phi, 
                                     <span class="dt">theta =</span> embeddings<span class="op">$</span>theta)</code></pre></div>
</div>
<div id="building-a-basic-document-summarizer" class="section level1">
<h1>Building a basic document summarizer</h1>
<p>Let’s use the above embeddings model to create a document summarizer. This will return the three most relevant sentences in each review.</p>
<p>The summarizer works best as a function, as we have many documents to summarize. The function <code>summarizer</code> is defined in the next section. However, let’s look at some key bits of code in detail.</p>
<p>The variable <code>doc</code> represents a single document, or a single element of a character vector.</p>
<p>In the code chunk below, we split the document into sentences using the <code>stringi</code> package. Then we embed each sentence under the model built on our whole corpus, above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># parse it into sentences</span>
  sent &lt;-<span class="st"> </span>stringi<span class="op">::</span><span class="kw">stri_split_boundaries</span>(doc, <span class="dt">type =</span> <span class="st">&quot;sentence&quot;</span>)[[ <span class="dv">1</span> ]]
  
  <span class="kw">names</span>(sent) &lt;-<span class="st"> </span><span class="kw">seq_along</span>(sent) <span class="co"># so we know index and order</span>
  
  <span class="co"># embed the sentences in the model</span>
  e &lt;-<span class="st"> </span><span class="kw">CreateDtm</span>(sent, <span class="dt">ngram_window =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">verbose =</span> <span class="ot">FALSE</span>, <span class="dt">cpus =</span> <span class="dv">2</span>)
  
  <span class="co"># remove any documents with 2 or fewer words</span>
  e &lt;-<span class="st"> </span>e[ <span class="kw">rowSums</span>(e) <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span> , ]
  
  vocab &lt;-<span class="st"> </span><span class="kw">intersect</span>(<span class="kw">colnames</span>(e), <span class="kw">colnames</span>(phi_prime))
  
  e &lt;-<span class="st"> </span>e <span class="op">/</span><span class="st"> </span><span class="kw">rowSums</span>(e)
  
  e &lt;-<span class="st"> </span>e[ , vocab ] <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(phi_prime[ , vocab ])
  
  e &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(e)</code></pre></div>
<p>Next, we measure the distance between each of the sentences within the embedding space.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># get the pairwise distances between each embedded sentence</span>
  e_dist &lt;-<span class="st"> </span><span class="kw">CalcHellingerDist</span>(e)</code></pre></div>
<p>Since we are using a distance measure whose values fall between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, we can take <span class="math inline">\(1 - distance\)</span> to get a similarity. We’ll also re-scale it to be between 0 and 100. (The rescaling is just a cautionary measure so that we don’t run into numerical precision issues when performing calculations downstream.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># turn into a similarity matrix</span>
  g &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>e_dist) <span class="op">*</span><span class="st"> </span><span class="dv">100</span></code></pre></div>
<p>If you consider a similarity matrix to be an adjacency matrix, then you have a fully-connected graph. For the sake of potentially faster computation and with the hope of eliminating some noise, we will delete some edges. Going row-by-row, we will keep connections only to the top 3 most similar sentences.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># we don't need sentences connected to themselves</span>
  <span class="kw">diag</span>(g) &lt;-<span class="st"> </span><span class="dv">0</span>
  
  <span class="co"># turn into a nearest-neighbor graph</span>
  g &lt;-<span class="st"> </span><span class="kw">apply</span>(g, <span class="dv">1</span>, <span class="cf">function</span>(x){
    x[ x <span class="op">&lt;</span><span class="st"> </span><span class="kw">sort</span>(x, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)[ <span class="dv">3</span> ] ] &lt;-<span class="st"> </span><span class="dv">0</span>
    x
  })

  <span class="co"># by taking pointwise max, we'll make the matrix symmetric again</span>
  g &lt;-<span class="st"> </span><span class="kw">pmax</span>(g, <span class="kw">t</span>(g))</code></pre></div>
<p>Using the <code>igraph</code> package (with its own objects) to calculate eigenvector centrality. From there, we’ll take the top three sentences.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  g &lt;-<span class="st"> </span><span class="kw">graph.adjacency</span>(g, <span class="dt">mode =</span> <span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted =</span> <span class="ot">TRUE</span>)
  
  <span class="co"># calculate eigenvector centrality</span>
  ev &lt;-<span class="st"> </span><span class="kw">evcent</span>(g)
  
  <span class="co"># format the result</span>
  result &lt;-<span class="st"> </span>sent[ <span class="kw">names</span>(ev<span class="op">$</span>vector)[ <span class="kw">order</span>(ev<span class="op">$</span>vector, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)[ <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> ] ] ]
  
  result &lt;-<span class="st"> </span>result[ <span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">names</span>(result))) ]
  
  <span class="kw">paste</span>(result, <span class="dt">collapse =</span> <span class="st">&quot; &quot;</span>)</code></pre></div>
</div>
<div id="pulling-it-all-together" class="section level1">
<h1>Pulling it all together</h1>
<p>The code below puts itall together in a single function. The first few lines vectorize the code, so that we can summarize multiple documents from a singel function call.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">library</span>(igraph) 
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: 'igraph'</span>
<span class="co">#&gt; The following objects are masked from 'package:stats':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     decompose, spectrum</span>
<span class="co">#&gt; The following object is masked from 'package:base':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     union</span>

<span class="co"># let's do this in a function</span>

summarizer &lt;-<span class="st"> </span><span class="cf">function</span>(doc, phi_prime) {
  
  <span class="co"># recursive fanciness to handle multiple docs at once</span>
  <span class="cf">if</span> (<span class="kw">length</span>(doc) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span> )
    <span class="co"># use a try statement to catch any weirdness that may arise</span>
    <span class="kw">return</span>(<span class="kw">sapply</span>(doc, <span class="cf">function</span>(d) <span class="kw">try</span>(<span class="kw">summarizer</span>(d, phi_prime))))
  
  <span class="co"># parse it into sentences</span>
  sent &lt;-<span class="st"> </span>stringi<span class="op">::</span><span class="kw">stri_split_boundaries</span>(doc, <span class="dt">type =</span> <span class="st">&quot;sentence&quot;</span>)[[ <span class="dv">1</span> ]]
  
  <span class="kw">names</span>(sent) &lt;-<span class="st"> </span><span class="kw">seq_along</span>(sent) <span class="co"># so we know index and order</span>
  
  <span class="co"># embed the sentences in the model</span>
  e &lt;-<span class="st"> </span><span class="kw">CreateDtm</span>(sent, <span class="dt">ngram_window =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
  
  <span class="co"># remove any documents with 2 or fewer words</span>
  e &lt;-<span class="st"> </span>e[ <span class="kw">rowSums</span>(e) <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span> , ]
  
  vocab &lt;-<span class="st"> </span><span class="kw">intersect</span>(<span class="kw">colnames</span>(e), <span class="kw">colnames</span>(phi_prime))
  
  e &lt;-<span class="st"> </span>e <span class="op">/</span><span class="st"> </span><span class="kw">rowSums</span>(e)
  
  e &lt;-<span class="st"> </span>e[ , vocab ] <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(phi_prime[ , vocab ])
  
  e &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(e)
  
  <span class="co"># get the pairwise distances between each embedded sentence</span>
  e_dist &lt;-<span class="st"> </span><span class="kw">CalcHellingerDist</span>(e)
  
  <span class="co"># turn into a similarity matrix</span>
  g &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>e_dist) <span class="op">*</span><span class="st"> </span><span class="dv">100</span>
  
  <span class="co"># we don't need sentences connected to themselves</span>
  <span class="kw">diag</span>(g) &lt;-<span class="st"> </span><span class="dv">0</span>
  
  <span class="co"># turn into a nearest-neighbor graph</span>
  g &lt;-<span class="st"> </span><span class="kw">apply</span>(g, <span class="dv">1</span>, <span class="cf">function</span>(x){
    x[ x <span class="op">&lt;</span><span class="st"> </span><span class="kw">sort</span>(x, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)[ <span class="dv">3</span> ] ] &lt;-<span class="st"> </span><span class="dv">0</span>
    x
  })

  <span class="co"># by taking pointwise max, we'll make the matrix symmetric again</span>
  g &lt;-<span class="st"> </span><span class="kw">pmax</span>(g, <span class="kw">t</span>(g))
  
  g &lt;-<span class="st"> </span><span class="kw">graph.adjacency</span>(g, <span class="dt">mode =</span> <span class="st">&quot;undirected&quot;</span>, <span class="dt">weighted =</span> <span class="ot">TRUE</span>)
  
  <span class="co"># calculate eigenvector centrality</span>
  ev &lt;-<span class="st"> </span><span class="kw">evcent</span>(g)
  
  <span class="co"># format the result</span>
  result &lt;-<span class="st"> </span>sent[ <span class="kw">names</span>(ev<span class="op">$</span>vector)[ <span class="kw">order</span>(ev<span class="op">$</span>vector, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)[ <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> ] ] ]
  
  result &lt;-<span class="st"> </span>result[ <span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">names</span>(result))) ]
  
  <span class="kw">paste</span>(result, <span class="dt">collapse =</span> <span class="st">&quot; &quot;</span>)
}</code></pre></div>
<p>How well did we do? Let’s look at summaries from the first three reviews.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Let's see the summary of the first couple of reviews</span>
docs &lt;-<span class="st"> </span>movie_review<span class="op">$</span>review[ <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> ]
<span class="kw">names</span>(docs) &lt;-<span class="st"> </span>movie_review<span class="op">$</span>id[ <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> ]

sums &lt;-<span class="st"> </span><span class="kw">summarizer</span>(docs, <span class="dt">phi_prime =</span> embeddings<span class="op">$</span>phi_prime)

sums
<span class="co">#&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  2595_9 </span>
<span class="co">#&gt; &quot;Brilliant adaptation of the largely interior monologues of Leopold Bloom, Stephen Dedalus, and Molly Bloom by Joseph Strick in recreating the endearing portrait of Dublin on June 16, 1904 - Bloomsday - a day to be celebrated - double entendre intended!  Gunter Grass' novel, The Tin Drum filmed by Volker Schlndorff (1979)is another fine film adaptation of interior monologue which I favorably compare with Strick's film. While there are clearly recognized Dublin landmarks in the original novel and in the film, there are also recognizable characters, although with different names in the novel. &quot; </span>
<span class="co">#&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  8892_2 </span>
<span class="co">#&gt;                                                                                                                                                                                                                                                                                                                           &quot;Have to admit, this version disgraces Shakespeare upfront!  She's worse doing the scene when she is contemplating drinking the sleeping potion...god stop whining!  Olivia and Leonard's version is still the best, followed by Leslie Howard's version and then the current Leo and Clare!&quot; </span>
<span class="co">#&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  8620_8 </span>
<span class="co">#&gt;                                                                                                                                                                                                                                                                                                                                                        &quot;I just finished watching the 139 min version (widescreen) with some friends and we were blown away.  What the filmmakers do with the concept is unexpected and fun.  There are many uses of silence as well as slow-motion photography that work beautifully. &quot;</span></code></pre></div>
<p>Compare that to the whole reviews yourself.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
